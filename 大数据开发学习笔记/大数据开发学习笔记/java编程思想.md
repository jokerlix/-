## 1 对象导论
### 1.1 面向对象程序设计的基本特性
- 万物皆对象
-  程序是对象的集合，通过发送消息告诉彼此所要做的事情
-   每个对象都是类（class）的实例（instance)
-   某个特定类型的所有的对象都可接受同样的消息
### 1.2 每个对象都有相应的接口
```
Light lt = new light()
lt.on()
lt.off()
lt.brighten()
lt.dim()
```
上述代码是关于一个灯泡对象的类型名与接口名的运用
![[Pasted image 20210317221020.png]]
_上图中的类表格是UML图片_
### 1.3 对象是服务提供者
- 高内聚：软件设计的基本质量要求之一 意思一个软件构件在各个方面的组合很好，在好的面向对象设计中，每个对象都可以很好的完成自己的任务，但是不做多余的事情

- 低耦合：每个对象处理自己的任务，但是各个对象的任务很少重叠
### 1.4 被隐藏的具体实现（访问控制）
不是所有的类成员都可以随便使用的，需要对类使用者进行限制

三个在内部设定边界的关键字：``public`` `` private`` `` protected``
- public : 用public定义的元素对任何人都可以使用
- private：表示只能类创建者与类型的内部方法访问的元素
- protected: 基本功能与private相当，多出一个 继承的类可以访问protected成员
- 缺省：包访问权限，类可以访问在同一个包中的其他类的成员，在包之外如同指定了private
### 1.5 复用具体实现
最简单的复用：1.直接使用某个类的对象 2.将那个类的一个对象置于某个新的类中（创建一个成员对象）
组合（composition）：新的类由其他任意类型，任意数量组合成新的类
聚合（aggregation）：若组合是动态发生的
组合经常被视为``has-a`` 拥有关系
组合成的新类通常被声明为``private`` 

### 1.6 继承
通过继承能够用现有的类（父类）为基础复制出新的类（子类）
![[Pasted image 20210318095421.png]]
继承来的子类可以有父类的所有特性和行为，并且可以多出更多特性。
创建一个父类型表示核心概念，从父类派生出的子类使用不同的方式实现父类的核心功能。
![[Pasted image 20210318095843.png]]
当继承后，子类拥有父类的所有成员（private类型是拥有的，但是不可访问），并且复制了父类的所有接口。
``派生类与基类的类型是一致的``
两种方法可以导致子类与父类产生差异：
- 直接在子类中添加新的方法（不常用，每次想要实现新的功能只能添加）
- 重载(overriding):改变从父类继承的方法，但是方法名不变，直接用新的实现方法来覆盖。想要重载某种方法，直接在方法定义上重新创建方法体就行！

![[Pasted image 20210318100354.png]]

#### is-a 与 is-like-a 关系
is-a:继承过程中只是重载方法，但是不添加新的方法(完美替代)
is-like-a:继承过程中不光重载方法，并且添加新的方法(新类型具有旧类型的接口，但也包含其他接口方法)

### 1.7 多态
处理层次结构时候，不把一个对象当作一个特定的类型对待，而是当作基类对象对待。
```
void doSomething(Shape shape){
	shape.erase();
	...
	shape.draw();
}
```
上述方法可以和任意shape对话
```
Circle circle = new Circle();
Triangle triangle = new Triangle();
Line line = new Line();
doSomething(circle);
doSomething(triangle);
doSomething(line);
```
上述代码，doSomething() 方法会自动处理所有对象，并不需要对象的确切类型，类似于虚基类。
上述过程就是doSomething()方法自动将子类看成了父类。此方法叫做``向上转型``

![[Pasted image 20210318102426.png]]

java 编译器在编译doSomething()方法时候，并不能确切指导doSomething()要处理的确切类型.
### 1.8 单根继承结构
在java中所有的类都继承自``Object``类（终极基类）
单根继承结构保证了所有对象都具有一些共同的功能。
单根继承是的垃圾回收器实现变得更加容易。

### 1.9 容器
__问题__：在面对某个特定问题时候，我们不知道需要多少空间能定义多少个对象才能解决问题，只有在具体运行时期，才能知道需要多少空间来创建这些对象。

__解决办法__：创建一种新的对象类型``容器`` ,此对象类型持有对其他对象的引用。

__特点__：不需要知道多少个对象放置于容器中，在任何时候都可以随时扩充自己来容纳想要放置在其中的东西。

Java中包含了很多面向不同需求的各种类型的容器。List Map Set 队列 树 堆栈

__对容器进行选择原因__：
- 不同容器提供了不同类型的接口和外部行为
- 不同容器对于相同问题的解决效率不同
#### 参数化类型

在JAVA SE5 出现前：容器存储的对象只具有java的通用类型：``Object``
这导致所有的对象引用被置于容器时候，必须向上转型为object 类型，当从容器中取出之后就获取了object对象的引用。

解决上述问题只能在取出对象引用后``向下转型`` ，向下转型时会出现转型成为错误的类型，出现异常，

所以再取出对象引用后，必须向下转型的同时检查类型。

__参数化机制__：解决上述向下转型和检查的麻烦。``参数化类型就是将一个编译器可以自动定制作用域特定类型上的类``
```
ArrayList<Shape> shapes = new ArrayList<Shape>();
```

上述代码就是定制一个只能存储``Shape``对象的``ArrayList``容器

### 1.10 对象的生成与生命期
#### 动态内存分配方式
每个对象的存在都需要一定的内存资源，当我们不需要某给对象的时候就必须清理掉。

*但是销毁时候需要顾虑到销毁对象的时间。可能出现处理完某个对象之后，系统某个其他部分还在处理它。*

JAVA采用了``动态内存分配方式``。
__动态内存分配__：在堆(heap)的内存池中动态的创建对象。这种方式只有在``运行期间``才能知道多少对象，对象的生命周期如何，对象的具体类型。

如果需要一个新的对象，可以直接在需要的时刻在堆上直接创建，因为存储空间在运行期间被动态管理的。

因此动态内存分配方式 在创建和销毁对象的存储空间时间是很少的，大多数时间都花在分配存储空间上了。

Java创建新的对象的时候使用``new``关键字创建此对象的动态实例。

#### 生命周期
JAVA 提供了垃圾回收机制，可以自动发现对象何时不再被使用，并销毁。
垃圾回收机制避免了暗藏的内存泄漏问题。

### 1.11 异常处理
__异常是一种对象__,从出错地点被``抛出``，并被专门设计用来处理特定类型的错误的相应的异常处理器``捕获``。
异常处理是与正常程序执行``并行``的。是相对于正常程序执行的另一条路径,不会干扰正常的执行代码。
__异常不能被忽略__，要保证异常被抛出后在某处要被处理。

### 1.12 并发编程
__含义__：同一时刻处理多个任务。
__并发__：对大量的问题，可以将问题切分成多个可以独立运行的部分。从而提高程序的响应能力。
__线程__：在上述内容中，彼此独立运行的部分。常见例子就是用户界面，不用等待程序运行完成就能得到按钮响应。
线程只是为单一处理器分配执行时间的手段。
__隐患__:共享资源，若有多个并行任务都要访问同一个资源，就会出问题，导致资源被使用过程中被锁定。

## 2 一切都是对象
### 2.1 引用
由于一起都是对象，可以采用单一固定语法。操作的标识符实际上是对象的``引用(reference)``
 创建引用：
 ```
 String s; //创建引用，但是没有具体指向
 String s = "cst_is_a_mother_fucker!!!" //有具体对象指向
 String s = new String("cst_nmsl") //初始化一个字符串对象
 ```
 
 ### 2.2 对象的存储
 - 寄存器：位于处理器内部，最快的存储区域。
 - 堆栈：位于通用RAM（随机访问存储器）中，可以使用堆栈指针，快速进行存取。不存储对象，存储对象引用。需要知道存放在内部的所有项的具体生命周期。
 - 堆：通用的内存池（位于RAM区）,用于存放JAVA对象。不许知道生命周期。在堆里分配存储时有很大灵活性。使用堆存储分配和清理比堆栈需要更多时间。
 - 常量存储：一般放入ROM(只读存储器)。
 - 非RAM存储：存储在其他媒介上，需要时可以恢复成常规的RAM对象。比如JDBC技术。
 
 __基本类型__:由于某些特别小的简单的变量，往往不使用``new`` 关键在堆上创建，而是直接在堆栈中创建一个``非引用的自动变量``。
 基本类型的存储空间大小是``不变的``.
 ![[Pasted image 20210319102914.png]]
 ``BigInteger``和``BigDecimal``提供了用于高精度运算的类。运算需要调用专用的方法，速度会慢很多。
 
 __数组__:JAVA会确保数组会被初始化，并且不能再它的范围之外被访问。确保了安全性。当创建一个数组对象的时候，实际上就是创建了一个引用数组，并且每个引用都会被自动初始化成一个特定``null``值。
 
 ### 2.3对象的创建与销毁
 __引用作用域__：与CPP不同，Java没有所谓的作用域变量隐藏机制。
 ```
 {
	int x = 12;
	{
		int x = 23;
	}
 }
 ```
 上述代码，在cpp中是允许存在的，其中第一个x在第二个x定义的时候被隐藏起来了，但是java``不允许``这么做。
 
 __对象作用域__：如果使用``new``关键字创建一个对象，此对象可以存在于作用域之外。
 ```
 {
 	String s = new String("a String");
 }
 ```
 上述代码中，引用``s``在大括号结束后，就消失了，但是``s``所指向的``String``对象任然占用内存，java的``垃圾回收机制``会一直监视``new``创建的所有对象，找出不会被引用的对象，随后释放这些对象的内存空间，保证内存空间不会被占满。
 
 ### 2.4 创建新的数据类型：类
 ```
 class ATypeName{//定义类体}
 ```
 上述代码就引入了一个新的类型。 
 ```
 ATypeName a = new ATypeName();//使用new关键字创建了一个ATypeName类型的对象 a
 ```
 
 __字段和方放__:字段（数据成员），方法（函数成员）。
 注意：数据成员可以是任何类型的引用，或者是某个基础类型的一种。如果数据成员，是某个对象的引用，必须初始化这个引用。
 ```
 class DataOnly{
 	int i;
	double d;
	boolean b;
 }
 ```
 创建对象：
 ```
 DataOnly data = new DataOnly();
 ```
 给对象的数据成员赋值：
 ```
 data.i = 13;
 data.d = 12.1;
 data.b = false;
 ```
 想修改的对象是对象包含的其他对象：
 ```
 myPlane.leftTank.capacity = 100;
 ```
 __基本数据类型的初始值__:
 ![[Pasted image 20210319105923.png]]
 上表中的初始值有可能在程序运行过程中是不合法的，所以必要时候还是需要手动初始化。（不适用于局部变量）
 
 ### 2.5 方法、参数、返回值
 
 __方法(函数)基本组成__:名称、参数、返回值、方法体。
 ```
 ReturnType methodName(//Argument list){
 //Method body
 }
 ```
 
 __*``方法只能作为类的一部分进行创建，并且只能通过对象才能被调用``*__,并且这个对象必须能执行这个方法调用。
 调用方法：
 ```
 objectName.methodName(arg1,arg2,arg3)
 ```
 返回值：
 ```
 int x = a.f() //通过a对象调用f()方法 将返回值赋值给x ,x的类型要与返回值兼容
 ```
 
 __参数列表__:
 参数列表传递的实际上是``引用``此处传递的都是对象形式，在参数列表中必须指定每个传递对象的类型与名字。
 如果参数被设定成``String`` 类型，则必须要传递一个``String``对象。
 ```
 int storage(String s){
 	return s.length()*2;
 }//返回数组长度的两倍
 ```
 
 __static关键字__:执行``new``关键字才能创建对象，数据存储空间才会被创建，方法才能被外界调用。
 
 ``static``关键字使用的情景：
 - 只想为某一特定域分配单一存储空间，与创建对象无关。
 - 想要某个方法独立存在，即使没有创建对象，这个方法也能被调用。 
 ```
 Class StaticTest{
 	static int i = 47;
 }
 StaticTest st1 = new StaticTest();
 StaticTest st2 = new StaticTest();
 ```
 上述两个实例中 ``st1.i`` 与``st2.i`` 指向同一存储空间。有相同的值。
 
 __两种引用static变量的方法__:
 - 通过对象定位static变量:``st2.i``
 - 直接通过类名引用:``StaticTest.i``(使用类名引用static变量是__首选方式__)
 *如果使用一个引用后将值发生变化全部引用的值都将发生变化*
 ``StaticTest.i++`` 会导致所有的``st2.i`` 与``st1.i``的值都同时变成48
 
 静态方法逻辑类似于静态变量：
 ```
 class Incrementable{
 	static void increment(){StaticTest.i++}
 }
 ```
 __静态方法的两种引用方式__:
 - ```
 Incrementable sf = new Incrementable();
 sf.increment();
 - ```
 Incrementable.increment();//静态方法直接使用类名调用
```
```
__``static``*字段*与``static``*方法*的区别__:
- 一个``static``字段对于每个类都只有同一个存储空间，非``static``字段对于一个对象就有一个存储空间；
- ``static``方法只是在不创建任何对象的前提下就可以调用此类方法。

### 2.8 注释和嵌入式文档
#### 2.8.1 注释
```
/* 一行开头都有个*
 * This is a comment
 * that  continues
 * across lines
/
```
#### 2.8.2 注释文档
如果文档与代码是分离的 每次修改代码后，都需要相应的修改文档。将代码同文档连接起来，可以解决这个问题。

``javadoc`` JDK 内置工具，用来提取注释的工具。查找程序内的特殊注释标签，解析这些标签标记的信息，同时将相邻的注释的类名与方法名抽取出来。
``javadoc`` 输出的是一个HTML文件，可以使用Web浏览器查看。

*如何生成javadoc需要看一下相关提示*

所有javadoc命令只能在``/**``注释中出现，使用javadoc的方式有两种：
- 嵌入HTML
- 独立文档标签：以@字符开头，需要放置于注释行最前面。

注释文档类型：类注释，域注释，方法注释。
```
//:object/DOcumentation1.java
/** A class comment*/
public class Documentation1{
	/** A field comment*/
	public int i;
	/** A method comment */
	public void f(){}
}///:~
```

__注意__：javadoc只能为``public`` 和``protected``成员进行文档注释，``private``和``包内可访问成员``的注释会被忽略。
但是上述问题，``private``可以使用``-private``进行标记，以便把private成员的注释也包括在内。
上述代码输出的结果是个HTML文件。

#### 2.8.3 嵌入式HTML
略

#### 2.8.4 标签实例
1. @see:引用其他类：
	可以通过@see标签连接到其他文档
	
2. {@link package.class#member label}
		效果与@see相似 但是用于行内 
		
3. {@docRoot}
	 该标签产生到文档根目录的相对路径，用于文档树页面的显示超链接
	 

4. {@inheritDoc}
	从当前的这个类的最直接的基类中继承相关文档到当前的文档注释中
	
5. @version
	格式如下：``@version version-information`` 其中``version-information`` 可以是任何你认为包含在版本说明的重要信息。
	
6. @author
    使用方法``@author author-information`` 其中``author-information`` 包含重要信息就行
	
	
7. @since
	允许指定程序代码最早使用的版本。

8. @param 
	形式如``@param parameter-name description``
	其中 ``parameter-name`` 是方法的参数列表中的标识符 ``description`` 是对参数功能的描述 可以有多行
	
9. @return 
	用于方法文档,格式``@return description``  其中``description``是用来描述返回值的含义。
	
10. @throws 
	格式：``throws fully-qualified-class-name description`` 其中，``fully-qualilfied-class-name`` 是一个异常类的无歧义的名字，``description``是对于这个异常类的具体描述

### 2.9 编码风格
- 类名的首字母要大写
- 如果类名有好几个单词构成，则每个内部单词的首字母都要采取大写形式,例如：
	```
	class AllTheColorsDifferent{//...}
	```
- 方法名，字段名大体风格和类名相似，除了第一个单词的首字母不大写。